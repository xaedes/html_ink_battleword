{"version":3,"file":"ink-es2015.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/Error.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","export type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            comps.unshift(new Path.Component(namedChild.name));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      this._originNames = otherList.originNames;\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue = originStory.listDefinitions?.FindSingleItemListWithName(\n      myListItem\n    );\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n  public Contains(otherList: InkList) {\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string = \"\";\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    this.namedContent.set(namedContentObj.name, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null = currentContainer.ContentWithPathComponent(\n        comp\n      );\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content[index] = contentObj;\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content = this.content.concat(otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart,\n    EvalOutput,\n    EvalEnd,\n    Duplicate,\n    PopEvaluatedValue,\n    PopFunction,\n    PopTunnel,\n    BeginString,\n    EndString,\n    NoOp,\n    ChoiceCount,\n    Turns,\n    TurnsSince,\n    Random,\n    SeedRandom,\n    VisitIndex,\n    SequenceShuffleIndex,\n    StartThread,\n    Done,\n    End,\n    ListFromInt,\n    ListRange,\n    ListRandom,\n    ReadCount,\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<\n    ValueType,\n    BinaryOp<any> | UnaryOp<any>\n  > | null = null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkList, InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" + JSON.stringify(token)\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(\n              temps\n            );\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class VariablesState {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string, value: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // thr proxy object is not available in this context. we should warn the\n      // dev but writting to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject = JsonSerialisation.JTokenToRuntimeObject(\n          loadedToken\n        );\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer = this.ResolveVariablePointer(\n          varPointer\n        );\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 16807) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public ToString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StoryException } from \"./StoryException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  public readonly kInkSaveStateVersion = 9;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.ToString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (textContent !== null) {\n          sb.Append(textContent.value);\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n\n      for (let outputObj of this.outputStream) {\n        // var tag = outputObj as Tag;\n        let tag = asOrNull(outputObj, Tag);\n        if (tag !== null) {\n          this._currentTags.push(tag.text);\n        }\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"] as any[]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(\n        innerStrStart,\n        innerStrEnd - innerStrStart\n      );\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(tailLastNewlineIdx + 1, numSpaces)\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint = this.callStack.currentElement\n      .functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      funcContainer\n    );\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(typeof args[i] === \"number\" || typeof args[i] === \"string\") ||\n          args[i] instanceof InkList\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight = this.callStack.currentElement\n      .evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 20;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions = JsonSerialisation.JTokenToListDefinitions(\n          listDefsObj\n        );\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.ToString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl = this.PerformLogicAndFlowControl(\n      currentContentObj\n    );\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;\n      let choiceOnlyStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      choiceOnlyText = choiceOnlyStrVal.value || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      // var startStrVal = state.PopEvaluationStack () as StringValue;\n      let startStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      startText = startStrVal.value || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents = this.state.variablesState.GetVariableWithName(\n          varName\n        );\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EndString:\n          let contentStackForString: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container = this.state.callStack.currentElement.currentPointer\n          .container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound = this.mainContentContainer.namedContent.has(\n              name\n            );\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers = this._variableObservers.get(\n            specificVariableName\n          );\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let tag = asOrNull(c, Tag);\n      if (tag) {\n        if (tags == null) tags = [];\n        tags.push(tag.text);\n      } else break;\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<\n    string,\n    Story.VariableObserver[]\n  > | null = null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"names":["Path","[object Object]","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","isRelative","componentCount","length","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","path","index","pathToAppend","p","upwardMoves","isParent","join","value","substring","componentStrings","split","str","test","parseInt","otherPath","Equals","c","Debug","ValueType","PushPopType","ErrorType","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","indexOrName","parentId","toString","otherComp","Assert","condition","message","console","warn","trace","variable","NullException","throwNullException","InkObject","debugMetadata","_debugMetadata","parent","ownDebugMetadata","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","_path","comps","child","container","Container","namedChild","unshift","content","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","ancestor","prop","StringBuilder","string","Length","Append","format","args","replace","match","num","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","JSON","stringify","key","parse","isLikeInkListItem","inkListItem","item","hasOwnProperty","InkList","Map","super","otherList","_originNames","originNames","origins","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","result","singleElement","Add","Key","Value","myListItem","listValue","FindSingleItemListWithName","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","fromSerializedKey","has","serialized","serializedKey","set","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","initialOriginNames","max","minItem","inverse","list","items","ContainsKey","all","union","intersection","listToRemove","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","otherInkList","sort","x","y","localeCompare","sb","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","Create","targetType","valueObject","valueType","isTruthy","Bool","newType","BadCastException","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","oldValue","newValue","oldList","newList","SearchResult","correctObj","approximate","searchResult","_content","AddContent","namedOnlyContent","namedOnlyContentDict","namedContent","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","visitsShouldBeCounted","CountFlags","Visits","turnIndexShouldBeCounted","Turns","countingAtStartOnly","CountStartOnly","flag","pathToFirstLeafContent","_pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","AssertType","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","Glue","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","Pointer","PathByAppendingComponent","Divert","stackPushType","pushesToStack","_targetPath","targetObj","targetPointer","Resolve","_targetPointer","ResolvePath","StartOf","copy","targetPathString","CompactPathString","hasVariableTarget","variableDivertName","otherDivert","targetStr","isConditional","Function","ChoicePoint","onceOnly","pathOnChoice","_pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","VariableReference","containerForCount","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","GenerateNativeFunctionsIfNecessary","numberOfParameters","_isPrototype","functionName","_nativeFunctions","_name","_prototype","_numberOfParameters","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","Cast","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","All","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","nativeFunc","AddOpFuncForType","Tag","tagText","text","Choice","ListDefinition","_items","_itemNameToValues","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","isExternal","Tunnel","WriteProperty","externalArgs","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","undefined","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","sourcePath","originalThreadIndex","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","Story","storyContext","_startOfRoot","Reset","toCopy","_threads","otherThread","Copy","_threadCounter","elements","callStack","depth","currentElement","cs","callstack","currentElementIndex","currentThread","canPop","Thread","Element","jThreads","jThreadTok","jThreadObj","thread","w","WriteObject","WriteJson","newThread","threadIndex","forkedThread","canPopThread","splice","elementIsEvaluateFromGame","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","pop","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filtered","filter","callStackTrace","isCurrent","pointer","inExpressionEvaluation","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","previousPointer","PointerAtPath","e","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","listDefsOrigin","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","callback","variableChangedEventCallbacks","batchObservingVariableChanges","_batchObservingVariableChanges","_changedVariablesForBatchObs","currentValue","variableChangedEvent","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","namedVarKey","namedVarValue","globals","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","varPointer","ValueAtVariablePointer","variableValue","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","PRNG","seed","next","StatePatch","_globals","_changedVariables","_visitCounts","_turnIndices","visitCounts","turnIndices","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","_propertyNameStack","_collectionStack","None","_jsonObject","_stateStack","StateElement","Object","innerOrContent","IncrementChildCount","childCount","_currentPropertyName","PropertyName","escape","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","_currentString","currEl","Flow","story","SetJsonToken","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","threadAtGeneration","ThreadWithIndex","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","_currentFlow","kDefaultFlowName","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","storySeed","previousRandom","GoToStart","indented","ToString","ToJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","pathString","visitCountOut","_patch","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","callstackDepth","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","evaluationStack","_currentTurnIndex","currentPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","outputObj","textContent","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","currentFlowName","mainContentContainer","flowName","_namedFlows","flow","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","namedFlowKey","namedFlowValue","divertedPointer","didSafeExit","ApplyPatch","ApplyCountChanges","newCount","isVisit","WriteIntDictionary","kInkSaveStateVersion","inkVersionCurrent","jSaveVersion","kMinCompatibleLoadVersion","flowsObj","flowsObjDict","keys","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","flowObj","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","txt","inStringEvaluation","n","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","Pop","incrementingTurnIndex","newPointer","funcContainer","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","isWarning","Stopwatch","startTime","ElapsedMilliseconds","nVal","isFinite","_mainContentContainer","jsonString","_listDefinitions","_externals","rootObject","versionObj","formatFromFile","inkVersionMinimumCompatible","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","_asyncSaving","RemoveFlow_Internal","ContinueAsync","asyncContinueComplete","_asyncContinueActive","millisecsLimitAsync","_hasValidatedExternals","ValidateExternalBindings","_profiler","PreContinue","isAsyncTimeLimited","_recursiveContinueCount","ResetOutput","durationStopwatch","Start","_sawLookaheadUnsafeFunctionAfterNewline","ContinueSingleStep","AddError","Stop","_stateSnapshotAtLastNewline","RestoreStateSnapshot","_temporaryEvaluationContainer","onDidContinue","PostContinue","onError","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","_prevContainers","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","ForkThread","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","PeekEvaluationStack","overrideTunnelReturnTarget","popped","TryExitFunctionEvaluationFromGame","names","expected","errorMsg","contentStackForString","outputCountConsumed","command","PopFromOutputStream","reverse","choiceCount","extraNote","eitherCount","divertTarget","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","randomItem","assignedVal","Assign","foundValue","func","funcParams","resetCallstack","onChoosePathString","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","onMakeChoice","KnotContainerWithName","returnTextOutput","onEvaluateFunction","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","onCompleteEvaluateFunction","returned","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","allowExternalFunctionFallbacks","valueObj","funcResult","function","returnObj","lookaheadSafe","BindExternalFunctionGeneral","coercedArgs","TryCoerce","apply","missingExternals","from","innerContent","observer","_variableObservers","variableNames","observers","ObserveVariable","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","tags","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}