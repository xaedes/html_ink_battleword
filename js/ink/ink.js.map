{"version":3,"file":"ink.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/Value.ts","../src/engine/Container.ts","../src/engine/SearchResult.ts","../src/engine/ControlCommand.ts","../src/engine/PushPop.ts","../src/engine/Glue.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Error.ts","../src/engine/Story.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            comps.unshift(new Path.Component(namedChild.name));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      this._originNames = otherList.originNames;\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue = originStory.listDefinitions?.FindSingleItemListWithName(\n      myListItem\n    );\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n  public Contains(otherList: InkList) {\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string = \"\";\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    this.namedContent.set(namedContentObj.name, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null = currentContainer.ContentWithPathComponent(\n        comp\n      );\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content[index] = contentObj;\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content = this.content.concat(otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart,\n    EvalOutput,\n    EvalEnd,\n    Duplicate,\n    PopEvaluatedValue,\n    PopFunction,\n    PopTunnel,\n    BeginString,\n    EndString,\n    NoOp,\n    ChoiceCount,\n    Turns,\n    TurnsSince,\n    Random,\n    SeedRandom,\n    VisitIndex,\n    SequenceShuffleIndex,\n    StartThread,\n    Done,\n    End,\n    ListFromInt,\n    ListRange,\n    ListRandom,\n    ReadCount,\n\n    TOTAL_VALUES,\n  }\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<\n    ValueType,\n    BinaryOp<any> | UnaryOp<any>\n  > | null = null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkList, InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" + JSON.stringify(token)\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables = JsonSerialisation.JObjectToDictionaryRuntimeObjs(\n              temps\n            );\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class VariablesState {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string, value: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // thr proxy object is not available in this context. we should warn the\n      // dev but writting to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject = JsonSerialisation.JTokenToRuntimeObject(\n          loadedToken\n        );\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer = this.ResolveVariablePointer(\n          varPointer\n        );\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 16807) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public ToString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","export type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 20;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString:\n    | ((arg1: string, arg2: any[]) => void)\n    | null = null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions = JsonSerialisation.JTokenToListDefinitions(\n          listDefsObj\n        );\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.ToString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl = this.PerformLogicAndFlowControl(\n      currentContentObj\n    );\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;\n      let choiceOnlyStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      choiceOnlyText = choiceOnlyStrVal.value || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      // var startStrVal = state.PopEvaluationStack () as StringValue;\n      let startStrVal = asOrThrows(\n        this.state.PopEvaluationStack(),\n        StringValue\n      );\n      startText = startStrVal.value || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents = this.state.variablesState.GetVariableWithName(\n          varName\n        );\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EndString:\n          let contentStackForString: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container = this.state.callStack.currentElement.currentPointer\n          .container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound = this.mainContentContainer.namedContent.has(\n              name\n            );\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers = this._variableObservers.get(\n            specificVariableName\n          );\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let tag = asOrNull(c, Tag);\n      if (tag) {\n        if (tags == null) tags = [];\n        tags.push(tag.text);\n      } else break;\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<\n    string,\n    Story.VariableObserver[]\n  > | null = null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StoryException } from \"./StoryException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  public readonly kInkSaveStateVersion = 9;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.ToString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (textContent !== null) {\n          sb.Append(textContent.value);\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n\n      for (let outputObj of this.outputStream) {\n        // var tag = outputObj as Tag;\n        let tag = asOrNull(outputObj, Tag);\n        if (tag !== null) {\n          this._currentTags.push(tag.text);\n        }\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"] as any[]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(\n        innerStrStart,\n        innerStrEnd - innerStrStart\n      );\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(tailLastNewlineIdx + 1, numSpaces)\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint = this.callStack.currentElement\n      .functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      funcContainer\n    );\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(typeof args[i] === \"number\" || typeof args[i] === \"string\") ||\n          args[i] instanceof InkList\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight = this.callStack.currentElement\n      .evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n"],"names":["Path","Component","Debug","componentsString","head","tail","relative","_components","_componentsString","_isRelative","arguments","push","this","concat","Array","length","slice","self","lastComponentIdx","i","l","isIndex","index","pathToAppend","p","upwardMoves","isParent","join","isRelative","value","substring","split","str","test","parseInt","otherPath","Equals","c","path","Assert","condition","message","console","warn","trace","Error","asOrNull","obj","type","asOrThrows","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","_typeof","indexOrName","parentId","toString","otherComp","variable","NullException","throwNullException","InkObject","_debugMetadata","parent","debugMetadata","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","_path","comps","child","container","Container","namedChild","unshift","content","indexOf","nearestContainer","GetComponent","contentContainer","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","componentCount","newPathComps","up","ToParent","down","globalPathStr","relativePathStr","PathByAppendingPath","ConvertPathToRelative","ancestor","prop","StringBuilder","string","Append","format","args","replace","match","num","InkListItem","originName","itemName","nameParts","fullName","JSON","stringify","key","parse","isLikeInkListItem","Null","item","hasOwnProperty","InkList","Map","singleElement","otherList","_originNames","originNames","origins","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","result","Add","Key","Value","itemOrItemName","AddItem","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","fromSerializedKey","has","serialized","serializedKey","set","delete","size","maxOriginName","maxItem","every","Count","initialOriginName","initialOriginNames","max","isNull","list","items","ContainsKey","union","intersection","listToRemove","minItem","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","SetInitialOriginNames","otherInkList","sort","x","y","localeCompare","sb","NaN","myListItem","listValue","FindSingleItemListWithName","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","ValueType","AbstractValue","Create","targetType","valueObject","valueType","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","Bool","newType","BadCastException","_isNewline","_this2","_isInlineWhitespace","isNewline","isInlineWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","listOrSingleItem","singleValue","List","oldValue","newValue","oldList","newList","CountFlags","SearchResult","approximate","searchResult","_content","AddContent","namedOnlyContentDict","namedContent","inkObject","named","existingNamedOnly","namedOnlyContent","AddToNamedContentOnly","flags","visitsShouldBeCounted","Visits","turnIndexShouldBeCounted","Turns","countingAtStartOnly","CountStartOnly","flag","_pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentObj","TryAddNamedContent","namedContentObj","AssertType","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","AppendFormat","AppendLine","onlyNamed","ControlCommand","CommandType","PushPopType","Glue","commandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","Pointer","PathByAppendingComponent","Divert","stackPushType","pushesToStack","targetObj","_targetPath","targetPointer","Resolve","_targetPointer","ResolvePath","lastComponent","StartOf","copy","CompactPathString","variableDivertName","otherDivert","hasVariableTarget","targetStr","isConditional","Function","targetPathString","ChoicePoint","onceOnly","choiceTargetObj","_pathOnChoice","choiceTarget","pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","VariableReference","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","numberOfParameters","GenerateNativeFunctionsIfNecessary","_isPrototype","_name","_nativeFunctions","_prototype","_numberOfParameters","parameters","Call","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","isTruthy","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","originOfMaxItem","castedValue","Cast","functionName","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","GreaterThanOrEquals","LessThanOrEquals","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","Union","Without","Contains","Intersect","GreaterThan","LessThan","AddListUnaryOp","Invert","inverse","All","all","ListMin","MinAsList","ListMax","MaxAsList","ValueOfList","AddOpToNativeFunc","d1","d2","nativeFunc","AddOpFuncForType","Tag","tagText","text","Choice","ListDefinition","_items","_itemNameToValues","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","isExternal","Tunnel","WriteProperty","externalArgs","choicePoint","pathStringOnChoice","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","undefined","nameToVal","listContent","rawList","JObjectToChoice","JArrayToContainer","withoutName","countFlags","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","sourcePath","originalThreadIndex","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValue","nameValueKey","TOTAL_VALUES","CallStack","Story","storyContext","_startOfRoot","Reset","toCopy","_threads","otherThread","Copy","_threadCounter","callStack","elements","cs","callstack","Thread","Element","jThreadTok","thread","w","WriteObject","_this","WriteJson","newThread","currentThread","threadIndex","forkedThread","canPopThread","splice","elementIsEvaluateFromGame","currentElement","FunctionEvaluationFromGame","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","canPop","CanPop","pop","currentElementIndex","varValue","temporaryVariables","declareNew","contextElement","RetainListOriginsForAssignment","filtered","filter","isCurrent","pointer","inExpressionEvaluation","jThreadObj","jElementObj","pushPopType","currentContainerPathStr","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevPath","prevContentObjPath","previousPointer","PointerAtPath","e","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","listDefsOrigin","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","variableChangedEventCallbacks","callback","_batchObservingVariableChanges","_changedVariablesForBatchObs","currentValue","variableChangedEvent","varContents","patch","TryGetGlobal","_defaultGlobalVariables","SetGlobal","globals","namedVarKey","namedVarValue","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","constructor","GetRawVariableWithName","varPointer","ValueAtVariablePointer","variableValue","GetTemporaryVariableWithName","GetVariableWithName","setGlobal","GlobalVariableExistsWithName","ResolveVariablePointer","existingPointer","SetTemporaryVariable","batchObservingVariableChanges","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","PRNG","seed","next","StatePatch","_globals","_changedVariables","_visitCounts","_turnIndices","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","inner","StartNewObject","propertyName","newObject","state","State","Property","currentCollection","currentPropertyName","_propertyNameStack","None","_jsonObject","_collectionStack","_stateStack","StateElement","Object","innerOrContent","IncrementChildCount","childCount","_currentPropertyName","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","_currentString","currEl","ErrorType","OutputStateChange","Flow","jChoiceThreadsObj","story","SetJsonToken","outputStream","currentChoices","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","threadAtGeneration","ThreadWithIndex","jChoiceThreads","jSavedChoiceThread","foundActiveThread","StoryState","_currentFlow","kDefaultFlowName","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","storySeed","previousRandom","GoToStart","ToString","indented","ToJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","pathString","visitCountOut","_patch","TryGetVisitCount","containerPathStr","count2","currCount","VisitCountForContainer","SetVisitCount","SetTurnIndex","TryGetTurnIndex","index2","depth","canContinue","_currentErrors","_currentWarnings","_currentTurnIndex","hasError","currentErrors","currentWarnings","_outputStreamTextDirty","textContent","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","_outputStreamTagsDirty","_currentTags","mainContentContainer","flowName","flow","_namedFlows","variablesState","SwitchFlow_Internal","SwitchToDefaultFlow_Internal","namedFlowKey","namedFlowValue","hasWarning","evaluationStack","divertedPointer","didSafeExit","ApplyPatch","visitCounts","ApplyCountChanges","turnIndices","newCount","isVisit","WriteIntDictionary","kInkSaveStateVersion","inkVersionCurrent","jSaveVersion","kMinCompatibleLoadVersion","flowsObj","flowsObjDict","keys","currFlowName","entries","flowObj","divertPath","currentDivertTargetPath","JObjectToIntDictionary","objs","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","leadingSpaces","innerStrText","numSpaces","trailingSpaces","listTexts","innerStrStart","innerStrEnd","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","isNonWhitespace","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","txt","n","numberOfObjects","functionStartPoint","popType","TrimWhitespaceFromFunctionEnd","Pop","incrementingTurnIndex","newPointer","funcContainer","Push","PassArgumentsToEvaluationStack","PushEvaluationStack","callStackTrace","originalEvaluationStackHeight","returnedObj","poppedObj","PopEvaluationStack","PopCallStack","returnVal","isWarning","Stopwatch","startTime","nVal","isFinite","jsonString","_mainContentContainer","_listDefinitions","_externals","rootObject","versionObj","formatFromFile","inkVersionMinimumCompatible","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","choices","_state","IfAsyncWeCant","currentText","currentTags","currentFlowName","shouldReturn","ObserveVariableChange","VariableStateDidChangeEvent","bind","ResetGlobals","ResetErrors","ForceEnd","originalPointer","ChoosePath","ContinueInternal","SnapshotDefaultGlobals","_asyncSaving","RemoveFlow_Internal","ContinueAsync","_asyncContinueActive","millisecsLimitAsync","_hasValidatedExternals","ValidateExternalBindings","_profiler","PreContinue","isAsyncTimeLimited","_recursiveContinueCount","ResetOutput","durationStopwatch","Start","_sawLookaheadUnsafeFunctionAfterNewline","ContinueSingleStep","AddError","ElapsedMilliseconds","Stop","_stateSnapshotAtLastNewline","RestoreStateSnapshot","generatedChoices","_temporaryEvaluationContainer","onDidContinue","PostContinue","onError","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","inStringEvaluation","change","CalculateNewlineOutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","Continue","pathLengthToUse","CopyAndStartPatching","RestoreAfterPatch","ApplyAnyPatch","stateToSave","shouldAddToStream","containerToEnter","VisitContainer","contextIdx","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","ContextForVariableNamed","PushToOutputStream","NextContent","PushThread","atStart","IncrementVisitCountForContainer","RecordTurnIndexVisitToContainer","_prevContainers","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","conditionValue","showChoice","IsTruthy","startText","choiceOnlyText","ForkThread","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","output","evalCommand","PeekEvaluationStack","popped","names","expected","errorMsg","overrideTunnelReturnTarget","TryExitFunctionEvaluationFromGame","contentStackForString","outputCountConsumed","command","PopFromOutputStream","reverse","choiceCount","extraNote","eitherCount","divertTarget","correctObj","TurnsSinceForContainer","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","PopThread","listNameVal","generatedListValue","foundItem","targetList","ListWithSubRange","listItemIndex","listEnumerator","randomItem","assignedVal","Assign","foundValue","containerForCount","func","funcParams","resetCallstack","onChoosePathString","ResetCallstack","funcDetail","activityStr","SetChosenPath","VisitChangedContainersDueToDivert","choiceIdx","choiceToChoose","onMakeChoice","KnotContainerWithName","returnTextOutput","onEvaluateFunction","trim","outputStreamBefore","StartFunctionEvaluationFromGame","stringOutput","textOutput","CompleteFunctionEvaluationFromGame","onCompleteEvaluateFunction","returned","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","allowExternalFunctionFallbacks","valueObj","funcResult","function","returnObj","lookaheadSafe","BindExternalFunctionGeneral","_this3","coercedArgs","TryCoerce","apply","missingExternals","from","innerContent","observer","_variableObservers","variableNames","observers","ObserveVariable","specificVariableName","variableObservers","newValueObj","TagsAtStartOfFlowContainerWithPathString","flowContainer","firstContent","tags","didPop","IncrementContentPointer","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","lineNum","currentDebugMetadata","errorTypeStr","endLineNumber","fileName"],"mappings":"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"}